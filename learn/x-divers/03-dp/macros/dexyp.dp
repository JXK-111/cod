. This is dataplot macro   DEXYP.DP
. Purpose: Generate a DEX Youden plot
.          (= step 6 of the DEXPLOT.DP 10-step DEX analysis procedure)
. Date: May 2005 ==> February 2015
. Input
.    1. k (parameter)               = Total number of plot factors
.    2. y (vector)                  = Response variable
.    3. x1, x2, x3, . . . (vectors) = Factors
.    4. confsw (parameter)    = a (0,1) switch dictating whether confounding should be done (optional) (default =  not exist)
.
.    4. framet (parameter)          = top    frame line (in %) (optional) (default = 90)
.    5. frameb (parameter)          = bottom frame line (in %) (optional) (default = 20)
.
. -----start point-----
.
if tracesw exists and tracesw = 1; print "dexyp.dp"; end if
.
feedback save; feedback off
printing off
let bugswyp = 0
. print "start: bugswyp = ^bugswyp"
. pause
.
if bugswyp = 1
   print " "
   print "--At the Beginning of Step 6 (DEXYP.DP) . . ."
   print y x1 to x^k
   let n = number y
   print "   k = ^k"
   print "   n = ^n"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
. -----------------------------------------
. -----Do Analysis Step 6: Youden Plot-----
. -----------------------------------------
.
. -----Step 1: Check for missing input values-----
.
if bugswyp = 1; print "--At dexyp.dp step 1"
   if ibatch exists and ibatch = 0; pause; end if
end if
. print "project = ^project"
.
let string stmacro = dexyp.dp
if k not exist
   call determine_k.dp
end if
set check name output filliben
set check length output filliben
feedback on
let iflag = check name k y x1 to x^k
let iflag = check equal length y x1 to x^k
feedback off
.
. -----Step 2: Define plot settings-----
.
if bugswyp = 1; print "--At dexyp.dp step 2"
   if ibatch exists and ibatch = 0; pause; end if
end if
. print "project = ^project"
.
call dexplotinit.dp
call dexplotdefplotset.dp
.
. -----Step 3: Compute  all effect estimates and confounding-----
. -----        The number of effects                      (parameter) numeff
. -----        The dummy index (1 to numeff)              (vector)    effindex
. -----        The means at the "high" side               (vector)    meanh
. -----        The means at the "low"  side               (vector)    meanl
.
. -----        The effect estimates (ordered by | |)      (vector)    eff
. -----        The effect ID's                            (vectors)   effid1, effid2
. -----        The corresponding tags and confounding     (strings)   steft.. and stefc..
.
. -----        The relative effect estimates              (vector)    releff
. -----        The sd(effects)                            (vector)    sdeff
. -----        The t(effects)                             (vector)    teff
. -----        The residual SD for each single model      (vector)    rsd
. -----        The residual SD for each cumulative model  (vector)    cumrsd
. -----        The effect ID's (as multiplier definitions)(strings)   stcore1, stcore2, etc.
. -----        The effect confouding                      (strings)   stconf1, stconf2, etc.
.
if bugswyp = 1; print "--At dexyp.dp step 3"
   if ibatch exists and ibatch = 0; pause; end if
end if
. print "project = ^project"
.
if bugswyp = 1; print "confsw = ^confsw"; end if
.
let confsw2 = 0
if confsw not exist; let confsw2 = 1; end if
if confsw exists and confsw = 1; let confsw2 = 1; end if
if bugswyp = 1; print "confsw2 = ^confsw2"; end if
.
if confsw2 = 1
   if confdone exists and confdone = 0 or confdone not exist
      . call 2_level_design_effects_and_confounding.dp    ;. <=====================
      let stall = string combine x1 to x^k
      let conftag1 conftag2 = dex confound ^stall
      let corefac = dex core ^stall
      let corefac1 = corefa1
      let corefac2 = corefa2
      let corefac3 = corefa3
      let corefac4 = corefa4
      let corefac5 = corefa5
      let numcore = number corefac1
      let confdone = 1
      let coredone = 1
      call est.dp
   end if
end if
.
. -----Step 4.1: Generate a hidden dex mean plot to get plot limits-----
.
. print "bugswyp = ^bugswyp"
. pause
.
if bugswyp = 1; print "--At dexyp.dp step 6.1"
   if ibatch exists and ibatch = 0; pause; end if
end if

device 1 off; device 2 off; device 3 off
dex mean plot y x1 to x^k
device 1 on; device 2 on; device 3 on
.
. -----Step 4.2: Compute automatic plot limits-----
.
. here
.
if bugswyp = 1; print "--At dexyp.dp step 6.2"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
probe fy1min; let ybottom = probeval
probe fy1max; let ytop = probeval
. let leftz = 50
. let rightz = 80
let ydel = ytop-ybottom
. print "ytop = ^ytop   ybottom = ^ybottom"
. print "ydel = ^ydel"
. pause
.
. patch 2/5/16 from dex class
let ymeanz = mean y
let ydel1 = ymeanz - ybottom
let ydel2 = ytop - ymeanz
let ytop2 = ytop
let ybottom2 = ybottom
if ydel1 > ydel2; let ytop2 = ymeanz + ydel1; end if
if ydel1 < ydel2; let ybottom2 = ymeanz - ydel2; end if
let ydel = ydel1
if ydel2 > ydel1; let ydel = ydel2; end if
let ydel = 2*ydel
. print "ymeanz = ^ymeanz"
. print "ydel1 = ^ydel1   ydel2 = ^ydel2"
. print "ytop = ^ytop   ybottom = ^ybottom"
. print "ytop2 = ^ytop2   ybottom2 = ^ybottom2"
. print "ydel = ^ydel"
. pause
.
let leftz = ybottom2 + (1/14)*ydel; . 1/14 is correct for offset 5 5
let rightz = ytop2 - (1/14)*ydel
let dpz = 0
if ydel >= 1 and ydel <= 10
   let dpz = 1
else if ydel >= 0.1 and ydel <= 1
   let dpz = 2
else if ydel >= 0.01 and ydel <= .1
   let dpz = 3
else if ydel >= 0.001 and ydel <= .01
   let dpz = 4
else if ydel >= 0.0001 and ydel <= .001
   let dpz = 5
else if ydel >= 0.00001 and ydel <= .0001
   let dpz = 6
else if ydel >= 0.000001 and ydel <= .00001
   let dpz = 7
else if ydel >= 0.0000001 and ydel <= .000001
   let dpz = 8
end if
let leftzz = round(leftz,dpz)
let rightzz = round(rightz,dpz)
. print "ydel = ^ydel"
. print "leftz = ^leftz    rightz = ^rightz"
. print "leftzz = ^leftzz    rightzz = ^rightzz"
. print "dpz = ^dpz"
. pause
ylimits leftzz rightzz
xlimits leftzz rightzz
if yminyp exists; ymin ^yminyp; xmin ^yminyp; end if
if ymaxyp exists; ymax ^ymaxyp; xmax ^ymaxyp; end if
.
. -----Step 5: Define labels and generate the blank background plot-----
.
if bugswyp = 1; print "--At dexyp.dp step 7"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
char bl all
lines blank all
title Youden Plot
y1label Average Response for  +  Setting
x3label
if cy not exist; y1label Response Y for  +  Setting; end if
if cy exists; y1label Response Y (^cy) for  +  Setting; end if
if cy not exist; x1label Response Y for  -  Setting; end if
if cy exists; x1label Response Y (^cy) for  -  Setting; end if
label size labelsiz
tic label size ticlabsi
.
. print meanh meanl effindex
. pause
plot meanh meanl effindex
.
. -----Step 8: Determine plot characters and individually plot them out-----
.
if bugswyp = 1; print "--At dexyp.dp step 8"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
character justification cece all
loop for j = 1 1 numeff
   let plot character j = ^steft^j
end loop
let tagzj = sequence 1 1 numeff
drawdd symbol meanl meanh tagzj
delete tagzj
.
. -----Step 9: Draw a dotted cross-hair at (grand mean, grand mean)-----
.
if bugswyp = 1; print "--At dexyp.dp step 9"
   if ibatch exists and ibatch = 0; pause; end if
end if
. print "project = ^project"
.
lines solid
let ybar = mean y
. draw data ybar a ybar b
. draw data a ybar b ybar
.
let frametz = 90
let framebz = 20
if framet exists; let frametz = framet; end if
if frameb exists; let framebz = frameb; end if
drawdsds ybar framebz ybar frametz
.
drawsdsd 15 ybar 85 ybar
.
. -----Step 10: Write out confounding structure in the right margin-----
.
if confsw2 = 1
   if bugswyp = 1; print "--At dexyp.dp step 10: Write confound."
      if ibatch exists and ibatch = 0; pause; end if
   end if
   . print "project = ^project"
   . . feedback on
   hw 2 1;. new 5/11/05
   character justification lece all
   character blank all
   delete xpos ypos tagzj
   let ypos = combine yplot yplot
   let jstop = 2*numeff
   let xpos = 90 for i = 1 1 jstop
   let xpos = 86 for i = 1 1 numeff
   let tagzj = sequence 1 1 jstop
   loop for j = 1 1 numeff
      let plot character j = ^steft^j:
      .
      let icnt2 = numeff + j
      let string ch = ^stefc^j
      if ch <> -999
         let plot character icnt2 = ^stefc^j
      end if
   end loop
   drawsd symbol xpos ypos tagzj
   .
   hw 2 1
   let ypz = 90
   if framet exists; let ypz = ypz - (90 - framet); end if
   move 86 ypz
   text Factor: Confounding
   .
end if
.
. -----Step 11: Write ID's at important plot points-----
.
if bugswyp = 1; print "--At dexyp.dp step 11"
   if ibatch exists and ibatch = 0; pause; end if
end if
. print "project = ^project"
.
. -----Step 12: draw crosshairs at (gmeanz,gmeanz)-----
.
if bugswyp = 1; print "--At dexyp.dp step 12"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
let gmeanz = mean y
.
lines dotted
drawdsds gmeanz framebz gmeanz frametz
drawsdsd 15 gmeanz 85 gmeanz
lines bl
.
. -----Step 13: Annotate the plot-----
.
if bugswyp = 1; print "--At dexyp.dp step 13: write ID's"
   if ibatch exists and ibatch = 0; pause; end if
end if
call dexwriteproject.dp
call dexknbox.dp
.
if step exist
   let step = step + 1; hw 2 1; just left; move 5 95
   . text Step ^step
   call tagcorn.dp
end if
.
if annotate exists and annotate = 1
   if colorall exists; color ^colorall; end if
   call annotate.dp
end if
.
if stcorn1 exists
   call upperleft.dp
end if
.
if bugswyp = 1
   end capture
end if
.
. -----Step 14: All Done-----
.
if bugswyp = 1; print "--At dexyp.dp step 14: All Done"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
xlimits
ylimits
title
y1label
x1label
.
if bugswyp = 1; print "--At dexyp.dp final line"
   if ibatch exists and ibatch = 0; pause; end if
end if
.
feedback restore
.
if itime exists and itime = 1
   cpu time
   let t6 = cputime
end if
