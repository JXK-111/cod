. This is dataplot macro   core.dp
. Purpose: Determine the core vectors spanning the (n-1) space (or a large part of it)
.          for effect estimation calculations by the    est.dp    macro
.          Domain: a general 2-level design--in Yates order or not.
. Date: 3/5/15
. Input:
.    k                      (parameter) = number of design factors
.    x1, x2, etc.           (vectors)   = (-1,+1) vectors in the design
. Output:
.    numcore  (parameter)  = number of orthogonal core vectors
.    corefac1 (vector)     = id for the   1st   factor of the core vector
.    corefac2 (vector)     = id for the   2nd   factor of the core factor (where -999 => main effect)
.    corefac3 (vector)     = id for the   3rd   factor of the core factor (where -999 => main effect)
.    corefac4 (vector)     = id for the   4th   factor of the core factor (where -999 => main effect)
.    corefac5 (vector)     = id for the   5th   factor of the core factor (where -999 => main effect)
.    coredone  (parameter) = (0,1) indicator as to whether this routine has (ever) been executed (default = not exist)
.
. -----start point-----
.
let maxnoco = 100
.
let pausecor = 0
feedback off
printing off
.
if pausecor = 1
   print " "
   print "At the beginning of    core.dp"
   print "k = ^k"
   if k <= 15
      print x1 to x^k
   end if
   print "maxnoco = ^maxnoco"
end if
.
print " "
print "  2. Orthogonal core elements are now being determined . . ."
print " "
.
. -----Step 0: Check input arguments-----
.
let string stmacro = core.dp
let string stall = k
call checkinput.dp
.
if k exists
   loop for j = 1 1 k
      let string stall = x^j
   call checkinput.dp
   end loop
end if
.
. -----Step 1: Form the initial version of the output-----
.
if pausecor = 1; print "--At core.dp step 1: Initialize the output:; pause; end if
print "."
.
let n = number x1
.
let count = 0
.
loop for j = 1 1 k
   let count = count + 1
   let corefac1(count) = j
   let corefac2(count) = -999
   let corefac3(count) = -999
   let corefac4(count) = -999
   let corefac5(count) = -999
   let string stpr^count = x^j
end loop
.
if k >= 2
   let km1 = k - 1
   loop for j1 = 1 1 km1
      let j1p1 = j1 + 1
      loop for j2 = j1p1 1 k
         let count = count + 1
         let corefac1(count) = j1
         let corefac2(count) = j2
         let corefac3(count) = -999
         let corefac4(count) = -999
         let corefac5(count) = -999
         let string stpr^count = x^j1 * x^j2
      end loop
   end loop
end if
. print "step 1: after k = 2 count = ^count"
. pause
.
if count <= maxnoco
   if k >= 3
      let km2 = k - 2
      loop for j1 = 1 1 km2
         let j1p1 = j1 + 1
         loop for j2 = j1p1 1 km1
            let j2p1 = j2 + 1
            loop for j3 = j2p1 1 k
               let count = count + 1
               let corefac1(count) = j1
               let corefac2(count) = j2
               let corefac3(count) = j3
               let corefac4(count) = -999
               let corefac5(count) = -999
               let string stpr^count = x^j1 * x^j2 * x^j3
            end loop
         end loop
      end loop
   end if
end if
. print "step 1: after k = 3 count = ^count"
. pause
.
if count <= maxnoco
   if k >= 4
      let km3 = k - 3
      loop for j1 = 1 1 km3
         let j1p1 = j1 + 1
         loop for j2 = j1p1 1 km2
            let j2p1 = j2 + 1
            loop for j3 = j2p1 1 km1
               let j3p1 = j3 + 1
               loop for j4 = j3p1 1 k
                  let count = count + 1
                  let corefac1(count) = j1
                  let corefac2(count) = j2
                  let corefac3(count) = j3
                  let corefac4(count) = j4
                  let corefac5(count) = -999
                  let string stpr^count = x^j1 * x^j2 * x^j3 * x^j4
               end loop
            end loop
         end loop
      end loop
   end if
end if
. print "step 1: after k = 4 count = ^count"
. pause
.
. The following was commented out due to excessive run time for k = 10 (yielding numcore = 637)
.
if count <= maxnoco
   if k >= 5
      let km4 = k - 4
      loop for j1 = 1 1 km4
         let j1p1 = j1 + 1
         loop for j2 = j1p1 1 km3
            let j2p1 = j2 + 1
            loop for j3 = j2p1 1 km2
               let j3p1 = j3 + 1
               loop for j4 = j3p1 1 km1
                  let j4p1 = j4 + 1
                  loop for j5 = j4p1 1 k
                     let count = count + 1
                     let corefac1(count) = j1
                     let corefac2(count) = j2
                     let corefac3(count) = j3
                     let corefac4(count) = j4
                     let corefac5(count) = j5
                     let string stpr^count = x^j1 * x^j2 * x^j3 * x^j4 * x^j5
                  end loop
               end loop
            end loop
         end loop
      end loop
   end if
end if
. print "step 1: after k = 5 count = ^count"
. pause
.
. -----Step 2: Determine the number of core elements to keep for effect estimation (32)-----
.
if pausecor = 1; print "--At core.dp step 2: Define numcore"; pause; end if
print ". ."
.
let numcore = number corefac1
. print "at step 2: numcore = ^numcore"
. pause
.
let maxnumco = 32
.
. if numcore >= maxnumco
.    let numcore = maxnumco
. end if
.
if pausecor = 1
   print corefac1 corefac2 corefac3 corefac4 corefac5
   print "Maximum number of core elements (initial)     maxnoco = ^maxnoco"
   print "        Number of core elements (initial)     numcore = ^numcore"
   pause
end if
.
. -----Step 3: Sequentially compare the tentative core elements with all previous elements-----
.              I_f orthogonal, then tag the core element as acceptable, else tag as unacceptale-----
.
if pausecor = 1
print "--At core.dp step 3: Sequentially back check for orthognaloity"; pause
end if
print ". . . (Wait--this will take a while)"
.
loop for j = 1 1 numcore
   let coretag(j) = 1
end loop
.
let coretag(1) = 1
.
delete v1junk v2junk
loop for j1 = 2 1 numcore
   let v1junk = ^stpr^j1
   let j1m1 = j1 - 1
   loop for j2 = 1 1 j1m1
      let v2junk = ^stpr^j2
      let cz = corr v1junk v2junk
      let czabs = abs(cz)
      if czabs = 1; let coretag(j1) = 0; end if
      . print "numcore j1 j2 cz = ^numcore ^j1 ^j2 ^cz"
   end loop
end loop
.
if pausecor = 1; print corefac1 corefac2 corefac3 corefac4 corefac5 coretag; end if
.
. -----Step 4: Trim back the output vectors whenever correlation exists-----
.
if pausecor = 1; print "--At core.dp step 4: Trim the core vectors"; pause; end if
print ". . . ."
.
retain corefac1 corefac2 corefac3 corefac4 corefac5 coretag subset coretag 1
let numcore = number corefac1
if pausecor = 1
   print "numcore = ^numcore"
   pause
end if
.
. -----Step 5: Since the core effect determination is now done,
. -----        set a switch to indicate that-----
.
if pausecor = 1; print "--At core.dp step 5"; pause; end if
print ". . . . ."
.
let coredone = 1
.
. -----Step 9: All done-----
.
if pausecor = 1; print "--At core.dp step 9: All done"; pause; end if
print ". . . . . ."
.
if pausecor = 1
   let numcore = number corefac1
   print corefac1 corefac2 corefac3 corefac4 corefac5
   print "Number of core elements (final)     numcore = ^numcore"
   print "k = ^k   n = ^n"
   pause
end if
.
delete v1junk v2junk
.
